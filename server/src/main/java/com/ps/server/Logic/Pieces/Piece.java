package com.ps.server.Logic.Pieces;

import com.ps.server.Logic.Board;
import com.ps.server.Logic.Color;
import com.ps.server.Logic.Move;
import com.ps.server.Logic.Position;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public abstract class Piece {
    List<Move> legalMoves = new ArrayList<>();
    /** piece color: WHITE, BLACK */
    final public Color color;
    /** piece type: KING, QUEEN, KNIGHT, BISHOP, ROOK, PAWN */
    public final PieceType type;
    Board board;
    Position position;

    Piece(Color color, PieceType type, Position position) {
        this.color = color;
        this.type = type;
        this.position = position;
    }

    /**
     * Adds reference to board on witch the piece stands.
     * Later on piece will use the state on board to know where it can move.
     * @param board reference to board
     */
    public void addBoard(Board board) {
        this.board = board;
    }

    /**
     * Generates and returns list of semi legal moves.
     * Semi legal moves are all moves that a piece can make ignoring kings state (if king under capture) after the move
     * @return list of semi legal moves
     */
    abstract public List<Move> semiLegalMoves();

    /**
     * Generates and saves all legal moves it can make.
     * Legal moves are all possible moves that don't put king under capture.
     */
    public void update() {
        legalMoves = semiLegalMoves()
                .stream()
                .filter(board::validateIfAfterMoveKingNotInCapture)
                .collect(Collectors.toList());
    }

    /**
     * Checks if piece can capture king on given position (has semi legal move on this position)
     * @param kingsPosition kings position
     * @return true if king under this piece capture
     */
    abstract public boolean checkIfCanCaptureKingOn(Position kingsPosition);

    /**
     * Makes copy of the piece.
     * Copies its color, position and type but not reference to board
     * @return copy of the piece
     */
    public abstract Piece copy();

    /**
     * Returns position of the piece on the board (in bounds: row: 0-7 and column: 0-7)
     * @return position
     */
    public Position getPosition() {
        return position;
    }

    /**
     * Changes position of the piece on the board (in bounds: row: 0-7 and column: 0-7)
     * @param position new position
     */
    public void move(Position position) {
        this.position = position;
    }

    /**
     * @return an instance of Move to given destination, if there is no legal move to this destination returns null
     */
    public Move getMoveTo(Position dest) {
        return legalMoves.stream().filter(move -> move.dest.equalsToPos(dest)).findFirst().orElse(null);
    }

    /**
     * @return true if list of pre saved legal moves is not empty
     */
    public boolean canMove() {
        return legalMoves.size() != 0;
    }

    boolean hasCastleRights() {
        return false;
    }

    /**
     * Gives en passant rights to capture pawn on specified position.
     * Rights are only saved by piece of type pawn and will be withdrawn after next update on piece.
     * @param position of the pawn to be captured by en passant
     */
    public void giveEnPassantRights(Position position) {}

    /**
     * Returns the list of pre saved legal moves.
     * The moves need to be generated by update method first.
     * @return list of legal moves
     */
    public List<Move> getListOfMoves() {
        return legalMoves;
    }

    /**
     * @return piece type: KING, QUEEN, KNIGHT, BISHOP, ROOK, PAWN
     */
    public PieceType getType() {
        return type;
    }

    public enum PieceType {
        KING, QUEEN, PAWN, ROOK, KNIGHT, BISHOP
    }
}
